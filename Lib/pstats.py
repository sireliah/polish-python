"""Class dla printing reports on profiled python code."""

# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may nie use this file wyjąwszy w compliance przy the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law albo agreed to w writing, software
# distributed under the License jest distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express albo implied.  See the License dla the specific language
# governing permissions oraz limitations under the License.


zaimportuj sys
zaimportuj os
zaimportuj time
zaimportuj marshal
zaimportuj re
z functools zaimportuj cmp_to_key

__all__ = ["Stats"]

klasa Stats:
    """This klasa jest used dla creating reports z data generated by the
    Profile class.  It jest a "friend" of that class, oraz imports data either
    by direct access to members of Profile class, albo by reading w a dictionary
    that was emitted (via marshal) z the Profile class.

    The big change z the previous Profiler (in terms of raw functionality)
    jest that an "add()" method has been provided to combine Stats from
    several distinct profile runs.  Both the constructor oraz the add()
    method now take arbitrarily many file names jako arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg jest a floating point number between 0 oraz 1.0, then
    it jest taken jako a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it jest an integer,
    it jest taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., w
    addition to the old -1, 0, 1, albo 2).  It takes an arbitrary number of
    quoted strings to select the sort order.  For example sort_stats('time',
    'name') sorts on the major key of 'internal function time', oraz on the
    minor key of 'the name of the function'.  Look at the two tables w
    sort_stats() oraz get_sort_arg_defs(self) dla more examples.

    All methods zwróć self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
    """

    def __init__(self, *args, stream=Nic):
        self.stream = stream albo sys.stdout
        jeżeli nie len(args):
            arg = Nic
        inaczej:
            arg = args[0]
            args = args[1:]
        self.init(arg)
        self.add(*args)

    def init(self, arg):
        self.all_callees = Nic  # calc only jeżeli needed
        self.files = []
        self.fcn_list = Nic
        self.total_tt = 0
        self.total_calls = 0
        self.prim_calls = 0
        self.max_name_len = 0
        self.top_level = set()
        self.stats = {}
        self.sort_arg_dict = {}
        self.load_stats(arg)
        spróbuj:
            self.get_top_level_stats()
        wyjąwszy Exception:
            print("Invalid timing data %s" %
                  (self.files[-1] jeżeli self.files inaczej ''), file=self.stream)
            podnieś

    def load_stats(self, arg):
        jeżeli arg jest Nic:
            self.stats = {}
            zwróć
        albo_inaczej isinstance(arg, str):
            przy open(arg, 'rb') jako f:
                self.stats = marshal.load(f)
            spróbuj:
                file_stats = os.stat(arg)
                arg = time.ctime(file_stats.st_mtime) + "    " + arg
            wyjąwszy:  # w case this jest nie unix
                dalej
            self.files = [arg]
        albo_inaczej hasattr(arg, 'create_stats'):
            arg.create_stats()
            self.stats = arg.stats
            arg.stats = {}
        jeżeli nie self.stats:
            podnieś TypeError("Cannot create albo construct a %r object z %r"
                            % (self.__class__, arg))
        zwróć

    def get_top_level_stats(self):
        dla func, (cc, nc, tt, ct, callers) w self.stats.items():
            self.total_calls += nc
            self.prim_calls  += cc
            self.total_tt    += tt
            jeżeli ("jprofile", 0, "profiler") w callers:
                self.top_level.add(func)
            jeżeli len(func_std_string(func)) > self.max_name_len:
                self.max_name_len = len(func_std_string(func))

    def add(self, *arg_list):
        jeżeli nie arg_list:
            zwróć self
        dla item w reversed(arg_list):
            jeżeli type(self) != type(item):
                item = Stats(item)
            self.files += item.files
            self.total_calls += item.total_calls
            self.prim_calls += item.prim_calls
            self.total_tt += item.total_tt
            dla func w item.top_level:
                self.top_level.add(func)

            jeżeli self.max_name_len < item.max_name_len:
                self.max_name_len = item.max_name_len

            self.fcn_list = Nic

            dla func, stat w item.stats.items():
                jeżeli func w self.stats:
                    old_func_stat = self.stats[func]
                inaczej:
                    old_func_stat = (0, 0, 0, 0, {},)
                self.stats[func] = add_func_stats(old_func_stat, stat)
        zwróć self

    def dump_stats(self, filename):
        """Write the profile data to a file we know how to load back."""
        przy open(filename, 'wb') jako f:
            marshal.dump(self.stats, f)

    # list the tuple indices oraz directions dla sorting,
    # along przy some printable description
    sort_arg_dict_default = {
              "calls"     : (((1,-1),              ), "call count"),
              "ncalls"    : (((1,-1),              ), "call count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              }

    def get_sort_arg_defs(self):
        """Expand all abbreviations that are unique."""
        jeżeli nie self.sort_arg_dict:
            self.sort_arg_dict = dict = {}
            bad_list = {}
            dla word, tup w self.sort_arg_dict_default.items():
                fragment = word
                dopóki fragment:
                    jeżeli nie fragment:
                        przerwij
                    jeżeli fragment w dict:
                        bad_list[fragment] = 0
                        przerwij
                    dict[fragment] = tup
                    fragment = fragment[:-1]
            dla word w bad_list:
                usuń dict[word]
        zwróć self.sort_arg_dict

    def sort_stats(self, *field):
        jeżeli nie field:
            self.fcn_list = 0
            zwróć self
        jeżeli len(field) == 1 oraz isinstance(field[0], int):
            # Be compatible przy old profiler
            field = [ {-1: "stdname",
                       0:  "calls",
                       1:  "time",
                       2:  "cumulative"}[field[0]] ]

        sort_arg_defs = self.get_sort_arg_defs()
        sort_tuple = ()
        self.sort_type = ""
        connector = ""
        dla word w field:
            sort_tuple = sort_tuple + sort_arg_defs[word][0]
            self.sort_type += connector + sort_arg_defs[word][1]
            connector = ", "

        stats_list = []
        dla func, (cc, nc, tt, ct, callers) w self.stats.items():
            stats_list.append((cc, nc, tt, ct) + func +
                              (func_std_string(func), func))

        stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare))

        self.fcn_list = fcn_list = []
        dla tuple w stats_list:
            fcn_list.append(tuple[-1])
        zwróć self

    def reverse_order(self):
        jeżeli self.fcn_list:
            self.fcn_list.reverse()
        zwróć self

    def strip_dirs(self):
        oldstats = self.stats
        self.stats = newstats = {}
        max_name_len = 0
        dla func, (cc, nc, tt, ct, callers) w oldstats.items():
            newfunc = func_strip_path(func)
            jeżeli len(func_std_string(newfunc)) > max_name_len:
                max_name_len = len(func_std_string(newfunc))
            newcallers = {}
            dla func2, caller w callers.items():
                newcallers[func_strip_path(func2)] = caller

            jeżeli newfunc w newstats:
                newstats[newfunc] = add_func_stats(
                                        newstats[newfunc],
                                        (cc, nc, tt, ct, newcallers))
            inaczej:
                newstats[newfunc] = (cc, nc, tt, ct, newcallers)
        old_top = self.top_level
        self.top_level = new_top = set()
        dla func w old_top:
            new_top.add(func_strip_path(func))

        self.max_name_len = max_name_len

        self.fcn_list = Nic
        self.all_callees = Nic
        zwróć self

    def calc_callees(self):
        jeżeli self.all_callees:
            zwróć
        self.all_callees = all_callees = {}
        dla func, (cc, nc, tt, ct, callers) w self.stats.items():
            jeżeli nie func w all_callees:
                all_callees[func] = {}
            dla func2, caller w callers.items():
                jeżeli nie func2 w all_callees:
                    all_callees[func2] = {}
                all_callees[func2][func]  = caller
        zwróć

    #******************************************************************
    # The following functions support actual printing of reports
    #******************************************************************

    # Optional "amount" jest either a line count, albo a percentage of lines.

    def eval_print_amount(self, sel, list, msg):
        new_list = list
        jeżeli isinstance(sel, str):
            spróbuj:
                rex = re.compile(sel)
            wyjąwszy re.error:
                msg += "   <Invalid regular expression %r>\n" % sel
                zwróć new_list, msg
            new_list = []
            dla func w list:
                jeżeli rex.search(func_std_string(func)):
                    new_list.append(func)
        inaczej:
            count = len(list)
            jeżeli isinstance(sel, float) oraz 0.0 <= sel < 1.0:
                count = int(count * sel + .5)
                new_list = list[:count]
            albo_inaczej isinstance(sel, int) oraz 0 <= sel < count:
                count = sel
                new_list = list[:count]
        jeżeli len(list) != len(new_list):
            msg += "   List reduced z %r to %r due to restriction <%r>\n" % (
                len(list), len(new_list), sel)

        zwróć new_list, msg

    def get_print_list(self, sel_list):
        width = self.max_name_len
        jeżeli self.fcn_list:
            stat_list = self.fcn_list[:]
            msg = "   Ordered by: " + self.sort_type + '\n'
        inaczej:
            stat_list = list(self.stats.keys())
            msg = "   Random listing order was used\n"

        dla selection w sel_list:
            stat_list, msg = self.eval_print_amount(selection, stat_list, msg)

        count = len(stat_list)

        jeżeli nie stat_list:
            zwróć 0, stat_list
        print(msg, file=self.stream)
        jeżeli count < len(self.stats):
            width = 0
            dla func w stat_list:
                jeżeli  len(func_std_string(func)) > width:
                    width = len(func_std_string(func))
        zwróć width+2, stat_list

    def print_stats(self, *amount):
        dla filename w self.files:
            print(filename, file=self.stream)
        jeżeli self.files:
            print(file=self.stream)
        indent = ' ' * 8
        dla func w self.top_level:
            print(indent, func_get_function_name(func), file=self.stream)

        print(indent, self.total_calls, "function calls", end=' ', file=self.stream)
        jeżeli self.total_calls != self.prim_calls:
            print("(%d primitive calls)" % self.prim_calls, end=' ', file=self.stream)
        print("in %.3f seconds" % self.total_tt, file=self.stream)
        print(file=self.stream)
        width, list = self.get_print_list(amount)
        jeżeli list:
            self.print_title()
            dla func w list:
                self.print_line(func)
            print(file=self.stream)
            print(file=self.stream)
        zwróć self

    def print_callees(self, *amount):
        width, list = self.get_print_list(amount)
        jeżeli list:
            self.calc_callees()

            self.print_call_heading(width, "called...")
            dla func w list:
                jeżeli func w self.all_callees:
                    self.print_call_line(width, func, self.all_callees[func])
                inaczej:
                    self.print_call_line(width, func, {})
            print(file=self.stream)
            print(file=self.stream)
        zwróć self

    def print_callers(self, *amount):
        width, list = self.get_print_list(amount)
        jeżeli list:
            self.print_call_heading(width, "was called by...")
            dla func w list:
                cc, nc, tt, ct, callers = self.stats[func]
                self.print_call_line(width, func, callers, "<-")
            print(file=self.stream)
            print(file=self.stream)
        zwróć self

    def print_call_heading(self, name_size, column_title):
        print("Function ".ljust(name_size) + column_title, file=self.stream)
        # print sub-header only jeżeli we have new-style callers
        subheader = Nieprawda
        dla cc, nc, tt, ct, callers w self.stats.values():
            jeżeli callers:
                value = next(iter(callers.values()))
                subheader = isinstance(value, tuple)
                przerwij
        jeżeli subheader:
            print(" "*name_size + "    ncalls  tottime  cumtime", file=self.stream)

    def print_call_line(self, name_size, source, call_dict, arrow="->"):
        print(func_std_string(source).ljust(name_size) + arrow, end=' ', file=self.stream)
        jeżeli nie call_dict:
            print(file=self.stream)
            zwróć
        clist = sorted(call_dict.keys())
        indent = ""
        dla func w clist:
            name = func_std_string(func)
            value = call_dict[func]
            jeżeli isinstance(value, tuple):
                nc, cc, tt, ct = value
                jeżeli nc != cc:
                    substats = '%d/%d' % (nc, cc)
                inaczej:
                    substats = '%d' % (nc,)
                substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
                                             f8(tt), f8(ct), name)
                left_width = name_size + 1
            inaczej:
                substats = '%s(%r) %s' % (name, value, f8(self.stats[func][3]))
                left_width = name_size + 3
            print(indent*left_width + substats, file=self.stream)
            indent = " "

    def print_title(self):
        print('   ncalls  tottime  percall  cumtime  percall', end=' ', file=self.stream)
        print('filename:lineno(function)', file=self.stream)

    def print_line(self, func):  # hack: should print percentages
        cc, nc, tt, ct, callers = self.stats[func]
        c = str(nc)
        jeżeli nc != cc:
            c = c + '/' + str(cc)
        print(c.rjust(9), end=' ', file=self.stream)
        print(f8(tt), end=' ', file=self.stream)
        jeżeli nc == 0:
            print(' '*8, end=' ', file=self.stream)
        inaczej:
            print(f8(tt/nc), end=' ', file=self.stream)
        print(f8(ct), end=' ', file=self.stream)
        jeżeli cc == 0:
            print(' '*8, end=' ', file=self.stream)
        inaczej:
            print(f8(ct/cc), end=' ', file=self.stream)
        print(func_std_string(func), file=self.stream)

klasa TupleComp:
    """This klasa provides a generic function dla comparing any two tuples.
    Each instance records a list of tuple-indices (z most significant
    to least significant), oraz sort direction (ascending albo decending) for
    each tuple-index.  The compare functions can then be used jako the function
    argument to the system sort() function when a list of tuples need to be
    sorted w the instances order."""

    def __init__(self, comp_select_list):
        self.comp_select_list = comp_select_list

    def compare (self, left, right):
        dla index, direction w self.comp_select_list:
            l = left[index]
            r = right[index]
            jeżeli l < r:
                zwróć -direction
            jeżeli l > r:
                zwróć direction
        zwróć 0


#**************************************************************************
# func_name jest a triple (file:string, line:int, name:string)

def func_strip_path(func_name):
    filename, line, name = func_name
    zwróć os.path.basename(filename), line, name

def func_get_function_name(func):
    zwróć func[2]

def func_std_string(func_name): # match what old profile produced
    jeżeli func_name[:2] == ('~', 0):
        # special case dla built-in functions
        name = func_name[2]
        jeżeli name.startswith('<') oraz name.endswith('>'):
            zwróć '{%s}' % name[1:-1]
        inaczej:
            zwróć name
    inaczej:
        zwróć "%s:%d(%s)" % func_name

#**************************************************************************
# The following functions combine statists dla pairs functions.
# The bulk of the processing involves correctly handling "call" lists,
# such jako callers oraz callees.
#**************************************************************************

def add_func_stats(target, source):
    """Add together all the stats dla two profile entries."""
    cc, nc, tt, ct, callers = source
    t_cc, t_nc, t_tt, t_ct, t_callers = target
    zwróć (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
              add_callers(t_callers, callers))

def add_callers(target, source):
    """Combine two caller lists w a single list."""
    new_callers = {}
    dla func, caller w target.items():
        new_callers[func] = caller
    dla func, caller w source.items():
        jeżeli func w new_callers:
            jeżeli isinstance(caller, tuple):
                # format used by cProfile
                new_callers[func] = tuple([i[0] + i[1] dla i w
                                           zip(caller, new_callers[func])])
            inaczej:
                # format used by profile
                new_callers[func] += caller
        inaczej:
            new_callers[func] = caller
    zwróć new_callers

def count_calls(callers):
    """Sum the caller statistics to get total number of calls received."""
    nc = 0
    dla calls w callers.values():
        nc += calls
    zwróć nc

#**************************************************************************
# The following functions support printing of reports
#**************************************************************************

def f8(x):
    zwróć "%8.3f" % x

#**************************************************************************
# Statistics browser added by ESR, April 2001
#**************************************************************************

jeżeli __name__ == '__main__':
    zaimportuj cmd
    spróbuj:
        zaimportuj readline
    wyjąwszy ImportError:
        dalej

    klasa ProfileBrowser(cmd.Cmd):
        def __init__(self, profile=Nic):
            cmd.Cmd.__init__(self)
            self.prompt = "% "
            self.stats = Nic
            self.stream = sys.stdout
            jeżeli profile jest nie Nic:
                self.do_read(profile)

        def generic(self, fn, line):
            args = line.split()
            processed = []
            dla term w args:
                spróbuj:
                    processed.append(int(term))
                    kontynuuj
                wyjąwszy ValueError:
                    dalej
                spróbuj:
                    frac = float(term)
                    jeżeli frac > 1 albo frac < 0:
                        print("Fraction argument must be w [0, 1]", file=self.stream)
                        kontynuuj
                    processed.append(frac)
                    kontynuuj
                wyjąwszy ValueError:
                    dalej
                processed.append(term)
            jeżeli self.stats:
                getattr(self.stats, fn)(*processed)
            inaczej:
                print("No statistics object jest loaded.", file=self.stream)
            zwróć 0
        def generic_help(self):
            print("Arguments may be:", file=self.stream)
            print("* An integer maximum number of entries to print.", file=self.stream)
            print("* A decimal fractional number between 0 oraz 1, controlling", file=self.stream)
            print("  what fraction of selected entries to print.", file=self.stream)
            print("* A regular expression; only entries przy function names", file=self.stream)
            print("  that match it are printed.", file=self.stream)

        def do_add(self, line):
            jeżeli self.stats:
                self.stats.add(line)
            inaczej:
                print("No statistics object jest loaded.", file=self.stream)
            zwróć 0
        def help_add(self):
            print("Add profile info z given file to current statistics object.", file=self.stream)

        def do_callees(self, line):
            zwróć self.generic('print_callees', line)
        def help_callees(self):
            print("Print callees statistics z the current stat object.", file=self.stream)
            self.generic_help()

        def do_callers(self, line):
            zwróć self.generic('print_callers', line)
        def help_callers(self):
            print("Print callers statistics z the current stat object.", file=self.stream)
            self.generic_help()

        def do_EOF(self, line):
            print("", file=self.stream)
            zwróć 1
        def help_EOF(self):
            print("Leave the profile brower.", file=self.stream)

        def do_quit(self, line):
            zwróć 1
        def help_quit(self):
            print("Leave the profile brower.", file=self.stream)

        def do_read(self, line):
            jeżeli line:
                spróbuj:
                    self.stats = Stats(line)
                wyjąwszy OSError jako err:
                    print(err.args[1], file=self.stream)
                    zwróć
                wyjąwszy Exception jako err:
                    print(err.__class__.__name__ + ':', err, file=self.stream)
                    zwróć
                self.prompt = line + "% "
            albo_inaczej len(self.prompt) > 2:
                line = self.prompt[:-2]
                self.do_read(line)
            inaczej:
                print("No statistics object jest current -- cannot reload.", file=self.stream)
            zwróć 0
        def help_read(self):
            print("Read w profile data z a specified file.", file=self.stream)
            print("Without argument, reload the current file.", file=self.stream)

        def do_reverse(self, line):
            jeżeli self.stats:
                self.stats.reverse_order()
            inaczej:
                print("No statistics object jest loaded.", file=self.stream)
            zwróć 0
        def help_reverse(self):
            print("Reverse the sort order of the profiling report.", file=self.stream)

        def do_sort(self, line):
            jeżeli nie self.stats:
                print("No statistics object jest loaded.", file=self.stream)
                zwróć
            abbrevs = self.stats.get_sort_arg_defs()
            jeżeli line oraz all((x w abbrevs) dla x w line.split()):
                self.stats.sort_stats(*line.split())
            inaczej:
                print("Valid sort keys (unique prefixes are accepted):", file=self.stream)
                dla (key, value) w Stats.sort_arg_dict_default.items():
                    print("%s -- %s" % (key, value[1]), file=self.stream)
            zwróć 0
        def help_sort(self):
            print("Sort profile data according to specified keys.", file=self.stream)
            print("(Typing `sort' without arguments lists valid keys.)", file=self.stream)
        def complete_sort(self, text, *args):
            zwróć [a dla a w Stats.sort_arg_dict_default jeżeli a.startswith(text)]

        def do_stats(self, line):
            zwróć self.generic('print_stats', line)
        def help_stats(self):
            print("Print statistics z the current stat object.", file=self.stream)
            self.generic_help()

        def do_strip(self, line):
            jeżeli self.stats:
                self.stats.strip_dirs()
            inaczej:
                print("No statistics object jest loaded.", file=self.stream)
        def help_strip(self):
            print("Strip leading path information z filenames w the report.", file=self.stream)

        def help_help(self):
            print("Show help dla a given command.", file=self.stream)

        def postcmd(self, stop, line):
            jeżeli stop:
                zwróć stop
            zwróć Nic

    jeżeli len(sys.argv) > 1:
        initprofile = sys.argv[1]
    inaczej:
        initprofile = Nic
    spróbuj:
        browser = ProfileBrowser(initprofile)
        dla profile w sys.argv[2:]:
            browser.do_add(profile)
        print("Welcome to the profile statistics browser.", file=browser.stream)
        browser.cmdloop()
        print("Goodbye.", file=browser.stream)
    wyjąwszy KeyboardInterrupt:
        dalej

# That's all, folks.
