"""Core implementation of path-based import.

This module jest NOT meant to be directly imported! It has been designed such
that it can be bootstrapped into Python jako the implementation of import. As
such it requires the injection of specific modules oraz attributes w order to
work. One should use importlib jako the public-facing version of this module.

"""
#
# IMPORTANT: Whenever making changes to this module, be sure to run
# a top-level make w order to get the frozen version of the module
# updated. Not doing so will result w the Makefile to fail for
# all others who don't have a ./python around to freeze the module
# w the early stages of compilation.
#

# See importlib._setup() dla what jest injected into the global namespace.

# When editing this code be aware that code executed at zaimportuj time CANNOT
# reference any injected objects! This includes nie only global code but also
# anything specified at the klasa level.

# Bootstrap-related code ######################################################

_CASE_INSENSITIVE_PLATFORMS = 'win', 'cygwin', 'darwin'


def _make_relax_case():
    jeżeli sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):
        def _relax_case():
            """Prawda jeżeli filenames must be checked case-insensitively."""
            zwróć b'PYTHONCASEOK' w _os.environ
    inaczej:
        def _relax_case():
            """Prawda jeżeli filenames must be checked case-insensitively."""
            zwróć Nieprawda
    zwróć _relax_case


def _w_long(x):
    """Convert a 32-bit integer to little-endian."""
    zwróć (int(x) & 0xFFFFFFFF).to_bytes(4, 'little')


def _r_long(int_bytes):
    """Convert 4 bytes w little-endian to an integer."""
    zwróć int.from_bytes(int_bytes, 'little')


def _path_join(*path_parts):
    """Replacement dla os.path.join()."""
    zwróć path_sep.join([part.rstrip(path_separators)
                          dla part w path_parts jeżeli part])


def _path_split(path):
    """Replacement dla os.path.split()."""
    jeżeli len(path_separators) == 1:
        front, _, tail = path.rpartition(path_sep)
        zwróć front, tail
    dla x w reversed(path):
        jeżeli x w path_separators:
            front, tail = path.rsplit(x, maxsplit=1)
            zwróć front, tail
    zwróć '', path


def _path_stat(path):
    """Stat the path.

    Made a separate function to make it easier to override w experiments
    (e.g. cache stat results).

    """
    zwróć _os.stat(path)


def _path_is_mode_type(path, mode):
    """Test whether the path jest the specified mode type."""
    spróbuj:
        stat_info = _path_stat(path)
    wyjąwszy OSError:
        zwróć Nieprawda
    zwróć (stat_info.st_mode & 0o170000) == mode


def _path_isfile(path):
    """Replacement dla os.path.isfile."""
    zwróć _path_is_mode_type(path, 0o100000)


def _path_isdir(path):
    """Replacement dla os.path.isdir."""
    jeżeli nie path:
        path = _os.getcwd()
    zwróć _path_is_mode_type(path, 0o040000)


def _write_atomic(path, data, mode=0o666):
    """Best-effort function to write data to a path atomically.
    Be prepared to handle a FileExistsError jeżeli concurrent writing of the
    temporary file jest attempted."""
    # id() jest used to generate a pseudo-random filename.
    path_tmp = '{}.{}'.format(path, id(path))
    fd = _os.open(path_tmp,
                  _os.O_EXCL | _os.O_CREAT | _os.O_WRONLY, mode & 0o666)
    spróbuj:
        # We first write data to a temporary file, oraz then use os.replace() to
        # perform an atomic rename.
        przy _io.FileIO(fd, 'wb') jako file:
            file.write(data)
        _os.replace(path_tmp, path)
    wyjąwszy OSError:
        spróbuj:
            _os.unlink(path_tmp)
        wyjąwszy OSError:
            dalej
        podnieś


_code_type = type(_write_atomic.__code__)


# Finder/loader utility code ###############################################

# Magic word to reject .pyc files generated by other Python versions.
# It should change dla each incompatible change to the bytecode.
#
# The value of CR oraz LF jest incorporated so jeżeli you ever read albo write
# a .pyc file w text mode the magic number will be wrong; also, the
# Apple MPW compiler swaps their values, botching string constants.
#
# The magic numbers must be spaced apart at least 2 values, jako the
# -U interpeter flag will cause MAGIC+1 being used. They have been
# odd numbers dla some time now.
#
# There were a variety of old schemes dla setting the magic number.
# The current working scheme jest to increment the previous value by
# 10.
#
# Starting przy the adoption of PEP 3147 w Python 3.2, every bump w magic
# number also includes a new "magic tag", i.e. a human readable string used
# to represent the magic number w __pycache__ directories.  When you change
# the magic number, you must also set a new unique magic tag.  Generally this
# can be named after the Python major version of the magic number bump, but
# it can really be anything, jako long jako it's different than anything inaczej
# that's come before.  The tags are included w the following table, starting
# przy Python 3.2a0.
#
# Known values:
#  Python 1.5:   20121
#  Python 1.5.1: 20121
#     Python 1.5.2: 20121
#     Python 1.6:   50428
#     Python 2.0:   50823
#     Python 2.0.1: 50823
#     Python 2.1:   60202
#     Python 2.1.1: 60202
#     Python 2.1.2: 60202
#     Python 2.2:   60717
#     Python 2.3a0: 62011
#     Python 2.3a0: 62021
#     Python 2.3a0: 62011 (!)
#     Python 2.4a0: 62041
#     Python 2.4a3: 62051
#     Python 2.4b1: 62061
#     Python 2.5a0: 62071
#     Python 2.5a0: 62081 (ast-branch)
#     Python 2.5a0: 62091 (with)
#     Python 2.5a0: 62092 (changed WITH_CLEANUP opcode)
#     Python 2.5b3: 62101 (fix wrong code: dla x, w ...)
#     Python 2.5b3: 62111 (fix wrong code: x += uzyskaj)
#     Python 2.5c1: 62121 (fix wrong lnotab przy dla loops oraz
#                          storing constants that should have been removed)
#     Python 2.5c2: 62131 (fix wrong code: dla x, w ... w listcomp/genexp)
#     Python 2.6a0: 62151 (peephole optimizations oraz STORE_MAP opcode)
#     Python 2.6a1: 62161 (WITH_CLEANUP optimization)
#     Python 2.7a0: 62171 (optimize list comprehensions/change LIST_APPEND)
#     Python 2.7a0: 62181 (optimize conditional branches:
#                          introduce POP_JUMP_IF_FALSE oraz POP_JUMP_IF_TRUE)
#     Python 2.7a0  62191 (introduce SETUP_WITH)
#     Python 2.7a0  62201 (introduce BUILD_SET)
#     Python 2.7a0  62211 (introduce MAP_ADD oraz SET_ADD)
#     Python 3000:   3000
#                    3010 (removed UNARY_CONVERT)
#                    3020 (added BUILD_SET)
#                    3030 (added keyword-only parameters)
#                    3040 (added signature annotations)
#                    3050 (print becomes a function)
#                    3060 (PEP 3115 metaclass syntax)
#                    3061 (string literals become unicode)
#                    3071 (PEP 3109 podnieś changes)
#                    3081 (PEP 3137 make __file__ oraz __name__ unicode)
#                    3091 (kill str8 interning)
#                    3101 (merge z 2.6a0, see 62151)
#                    3103 (__file__ points to source file)
#     Python 3.0a4: 3111 (WITH_CLEANUP optimization).
#     Python 3.0a5: 3131 (lexical exception stacking, including POP_EXCEPT)
#     Python 3.1a0: 3141 (optimize list, set oraz dict comprehensions:
#             change LIST_APPEND oraz SET_ADD, add MAP_ADD)
#     Python 3.1a0: 3151 (optimize conditional branches:
#             introduce POP_JUMP_IF_FALSE oraz POP_JUMP_IF_TRUE)
#     Python 3.2a0: 3160 (add SETUP_WITH)
#                   tag: cpython-32
#     Python 3.2a1: 3170 (add DUP_TOP_TWO, remove DUP_TOPX oraz ROT_FOUR)
#                   tag: cpython-32
#     Python 3.2a2  3180 (add DELETE_DEREF)
#     Python 3.3a0  3190 __class__ super closure changed
#     Python 3.3a0  3200 (__qualname__ added)
#                      3210 (added size modulo 2**32 to the pyc header)
#     Python 3.3a1  3220 (changed PEP 380 implementation)
#     Python 3.3a4  3230 (revert changes to implicit __class__ closure)
#     Python 3.4a1  3250 (evaluate positional default arguments before
#                        keyword-only defaults)
#     Python 3.4a1  3260 (add LOAD_CLASSDEREF; allow locals of klasa to override
#                        free vars)
#     Python 3.4a1  3270 (various tweaks to the __class__ closure)
#     Python 3.4a1  3280 (remove implicit klasa argument)
#     Python 3.4a4  3290 (changes to __qualname__ computation)
#     Python 3.4a4  3300 (more changes to __qualname__ computation)
#     Python 3.4rc2 3310 (alter __qualname__ computation)
#     Python 3.5a0  3320 (matrix multiplication operator)
#     Python 3.5b1  3330 (PEP 448: Additional Unpacking Generalizations)
#     Python 3.5b2  3340 (fix dictionary display evaluation order #11205)
#     Python 3.5b2  3350 (add GET_YIELD_FROM_ITER opcode #24400)
#
# MAGIC must change whenever the bytecode emitted by the compiler may no
# longer be understood by older implementations of the eval loop (usually
# due to the addition of new opcodes).

MAGIC_NUMBER = (3350).to_bytes(2, 'little') + b'\r\n'
_RAW_MAGIC_NUMBER = int.from_bytes(MAGIC_NUMBER, 'little')  # For import.c

_PYCACHE = '__pycache__'
_OPT = 'opt-'

SOURCE_SUFFIXES = ['.py']  # _setup() adds .pyw jako needed.

BYTECODE_SUFFIXES = ['.pyc']
# Deprecated.
DEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES

def cache_from_source(path, debug_override=Nic, *, optimization=Nic):
    """Given the path to a .py file, zwróć the path to its .pyc file.

    The .py file does nie need to exist; this simply returns the path to the
    .pyc file calculated jako jeżeli the .py file were imported.

    The 'optimization' parameter controls the presumed optimization level of
    the bytecode file. If 'optimization' jest nie Nic, the string representation
    of the argument jest taken oraz verified to be alphanumeric (inaczej ValueError
    jest podnieśd).

    The debug_override parameter jest deprecated. If debug_override jest nie Nic,
    a Prawda value jest the same jako setting 'optimization' to the empty string
    dopóki a Nieprawda value jest equivalent to setting 'optimization' to '1'.

    If sys.implementation.cache_tag jest Nic then NotImplementedError jest podnieśd.

    """
    jeżeli debug_override jest nie Nic:
        _warnings.warn('the debug_override parameter jest deprecated; use '
                       "'optimization' instead", DeprecationWarning)
        jeżeli optimization jest nie Nic:
            message = 'debug_override albo optimization must be set to Nic'
            podnieś TypeError(message)
        optimization = '' jeżeli debug_override inaczej 1
    head, tail = _path_split(path)
    base, sep, rest = tail.rpartition('.')
    tag = sys.implementation.cache_tag
    jeżeli tag jest Nic:
        podnieś NotImplementedError('sys.implementation.cache_tag jest Nic')
    almost_filename = ''.join([(base jeżeli base inaczej rest), sep, tag])
    jeżeli optimization jest Nic:
        jeżeli sys.flags.optimize == 0:
            optimization = ''
        inaczej:
            optimization = sys.flags.optimize
    optimization = str(optimization)
    jeżeli optimization != '':
        jeżeli nie optimization.isalnum():
            podnieś ValueError('{!r} jest nie alphanumeric'.format(optimization))
        almost_filename = '{}.{}{}'.format(almost_filename, _OPT, optimization)
    zwróć _path_join(head, _PYCACHE, almost_filename + BYTECODE_SUFFIXES[0])


def source_from_cache(path):
    """Given the path to a .pyc. file, zwróć the path to its .py file.

    The .pyc file does nie need to exist; this simply returns the path to
    the .py file calculated to correspond to the .pyc file.  If path does
    nie conform to PEP 3147/488 format, ValueError will be podnieśd. If
    sys.implementation.cache_tag jest Nic then NotImplementedError jest podnieśd.

    """
    jeżeli sys.implementation.cache_tag jest Nic:
        podnieś NotImplementedError('sys.implementation.cache_tag jest Nic')
    head, pycache_filename = _path_split(path)
    head, pycache = _path_split(head)
    jeżeli pycache != _PYCACHE:
        podnieś ValueError('{} nie bottom-level directory w '
                         '{!r}'.format(_PYCACHE, path))
    dot_count = pycache_filename.count('.')
    jeżeli dot_count nie w {2, 3}:
        podnieś ValueError('expected only 2 albo 3 dots w '
                         '{!r}'.format(pycache_filename))
    albo_inaczej dot_count == 3:
        optimization = pycache_filename.rsplit('.', 2)[-2]
        jeżeli nie optimization.startswith(_OPT):
            podnieś ValueError("optimization portion of filename does nie start "
                             "przy {!r}".format(_OPT))
        opt_level = optimization[len(_OPT):]
        jeżeli nie opt_level.isalnum():
            podnieś ValueError("optimization level {!r} jest nie an alphanumeric "
                             "value".format(optimization))
    base_filename = pycache_filename.partition('.')[0]
    zwróć _path_join(head, base_filename + SOURCE_SUFFIXES[0])


def _get_sourcefile(bytecode_path):
    """Convert a bytecode file path to a source path (jeżeli possible).

    This function exists purely dla backwards-compatibility for
    PyImport_ExecCodeModuleWithFilenames() w the C API.

    """
    jeżeli len(bytecode_path) == 0:
        zwróć Nic
    rest, _, extension = bytecode_path.rpartition('.')
    jeżeli nie rest albo extension.lower()[-3:-1] != 'py':
        zwróć bytecode_path
    spróbuj:
        source_path = source_from_cache(bytecode_path)
    wyjąwszy (NotImplementedError, ValueError):
        source_path = bytecode_path[:-1]
    zwróć source_path jeżeli _path_isfile(source_path) inaczej bytecode_path


def _get_cached(filename):
    jeżeli filename.endswith(tuple(SOURCE_SUFFIXES)):
        spróbuj:
            zwróć cache_from_source(filename)
        wyjąwszy NotImplementedError:
            dalej
    albo_inaczej filename.endswith(tuple(BYTECODE_SUFFIXES)):
        zwróć filename
    inaczej:
        zwróć Nic


def _calc_mode(path):
    """Calculate the mode permissions dla a bytecode file."""
    spróbuj:
        mode = _path_stat(path).st_mode
    wyjąwszy OSError:
        mode = 0o666
    # We always ensure write access so we can update cached files
    # later even when the source files are read-only on Windows (#6074)
    mode |= 0o200
    zwróć mode


def _verbose_message(message, *args, verbosity=1):
    """Print the message to stderr jeżeli -v/PYTHONVERBOSE jest turned on."""
    jeżeli sys.flags.verbose >= verbosity:
        jeżeli nie message.startswith(('#', 'zaimportuj ')):
            message = '# ' + message
        print(message.format(*args), file=sys.stderr)


def _check_name(method):
    """Decorator to verify that the module being requested matches the one the
    loader can handle.

    The first argument (self) must define _name which the second argument jest
    compared against. If the comparison fails then ImportError jest podnieśd.

    """
    def _check_name_wrapper(self, name=Nic, *args, **kwargs):
        jeżeli name jest Nic:
            name = self.name
        albo_inaczej self.name != name:
            podnieś ImportError('loader dla %s cannot handle %s' %
                                (self.name, name), name=name)
        zwróć method(self, name, *args, **kwargs)
    spróbuj:
        _wrap = _bootstrap._wrap
    wyjąwszy NameError:
        # XXX yuck
        def _wrap(new, old):
            dla replace w ['__module__', '__name__', '__qualname__', '__doc__']:
                jeżeli hasattr(old, replace):
                    setattr(new, replace, getattr(old, replace))
            new.__dict__.update(old.__dict__)
    _wrap(_check_name_wrapper, method)
    zwróć _check_name_wrapper


def _find_module_shim(self, fullname):
    """Try to find a loader dla the specified module by delegating to
    self.find_loader().

    This method jest deprecated w favor of finder.find_spec().

    """
    # Call find_loader(). If it returns a string (indicating this
    # jest a namespace package portion), generate a warning oraz
    # zwróć Nic.
    loader, portions = self.find_loader(fullname)
    jeżeli loader jest Nic oraz len(portions):
        msg = 'Not importing directory {}: missing __init__'
        _warnings.warn(msg.format(portions[0]), ImportWarning)
    zwróć loader


def _validate_bytecode_header(data, source_stats=Nic, name=Nic, path=Nic):
    """Validate the header of the dalejed-in bytecode against source_stats (if
    given) oraz returning the bytecode that can be compiled by compile().

    All other arguments are used to enhance error reporting.

    ImportError jest podnieśd when the magic number jest incorrect albo the bytecode jest
    found to be stale. EOFError jest podnieśd when the data jest found to be
    truncated.

    """
    exc_details = {}
    jeżeli name jest nie Nic:
        exc_details['name'] = name
    inaczej:
        # To prevent having to make all messages have a conditional name.
        name = '<bytecode>'
    jeżeli path jest nie Nic:
        exc_details['path'] = path
    magic = data[:4]
    raw_timestamp = data[4:8]
    raw_size = data[8:12]
    jeżeli magic != MAGIC_NUMBER:
        message = 'bad magic number w {!r}: {!r}'.format(name, magic)
        _verbose_message(message)
        podnieś ImportError(message, **exc_details)
    albo_inaczej len(raw_timestamp) != 4:
        message = 'reached EOF dopóki reading timestamp w {!r}'.format(name)
        _verbose_message(message)
        podnieś EOFError(message)
    albo_inaczej len(raw_size) != 4:
        message = 'reached EOF dopóki reading size of source w {!r}'.format(name)
        _verbose_message(message)
        podnieś EOFError(message)
    jeżeli source_stats jest nie Nic:
        spróbuj:
            source_mtime = int(source_stats['mtime'])
        wyjąwszy KeyError:
            dalej
        inaczej:
            jeżeli _r_long(raw_timestamp) != source_mtime:
                message = 'bytecode jest stale dla {!r}'.format(name)
                _verbose_message(message)
                podnieś ImportError(message, **exc_details)
        spróbuj:
            source_size = source_stats['size'] & 0xFFFFFFFF
        wyjąwszy KeyError:
            dalej
        inaczej:
            jeżeli _r_long(raw_size) != source_size:
                podnieś ImportError('bytecode jest stale dla {!r}'.format(name),
                                  **exc_details)
    zwróć data[12:]


def _compile_bytecode(data, name=Nic, bytecode_path=Nic, source_path=Nic):
    """Compile bytecode jako returned by _validate_bytecode_header()."""
    code = marshal.loads(data)
    jeżeli isinstance(code, _code_type):
        _verbose_message('code object z {!r}', bytecode_path)
        jeżeli source_path jest nie Nic:
            _imp._fix_co_filename(code, source_path)
        zwróć code
    inaczej:
        podnieś ImportError('Non-code object w {!r}'.format(bytecode_path),
                          name=name, path=bytecode_path)

def _code_to_bytecode(code, mtime=0, source_size=0):
    """Compile a code object into bytecode dla writing out to a byte-compiled
    file."""
    data = bytearray(MAGIC_NUMBER)
    data.extend(_w_long(mtime))
    data.extend(_w_long(source_size))
    data.extend(marshal.dumps(code))
    zwróć data


def decode_source(source_bytes):
    """Decode bytes representing source code oraz zwróć the string.

    Universal newline support jest used w the decoding.
    """
    zaimportuj tokenize  # To avoid bootstrap issues.
    source_bytes_readline = _io.BytesIO(source_bytes).readline
    encoding = tokenize.detect_encoding(source_bytes_readline)
    newline_decoder = _io.IncrementalNewlineDecoder(Nic, Prawda)
    zwróć newline_decoder.decode(source_bytes.decode(encoding[0]))


# Module specifications #######################################################

_POPULATE = object()


def spec_from_file_location(name, location=Nic, *, loader=Nic,
                            submodule_search_locations=_POPULATE):
    """Return a module spec based on a file location.

    To indicate that the module jest a package, set
    submodule_search_locations to a list of directory paths.  An
    empty list jest sufficient, though its nie otherwise useful to the
    zaimportuj system.

    The loader must take a spec jako its only __init__() arg.

    """
    jeżeli location jest Nic:
        # The caller may simply want a partially populated location-
        # oriented spec.  So we set the location to a bogus value oraz
        # fill w jako much jako we can.
        location = '<unknown>'
        jeżeli hasattr(loader, 'get_filename'):
            # ExecutionLoader
            spróbuj:
                location = loader.get_filename(name)
            wyjąwszy ImportError:
                dalej

    # If the location jest on the filesystem, but doesn't actually exist,
    # we could zwróć Nic here, indicating that the location jest nie
    # valid.  However, we don't have a good way of testing since an
    # indirect location (e.g. a zip file albo URL) will look like a
    # non-existent file relative to the filesystem.

    spec = _bootstrap.ModuleSpec(name, loader, origin=location)
    spec._set_fileattr = Prawda

    # Pick a loader jeżeli one wasn't provided.
    jeżeli loader jest Nic:
        dla loader_class, suffixes w _get_supported_file_loaders():
            jeżeli location.endswith(tuple(suffixes)):
                loader = loader_class(name, location)
                spec.loader = loader
                przerwij
        inaczej:
            zwróć Nic

    # Set submodule_search_paths appropriately.
    jeżeli submodule_search_locations jest _POPULATE:
        # Check the loader.
        jeżeli hasattr(loader, 'is_package'):
            spróbuj:
                is_package = loader.is_package(name)
            wyjąwszy ImportError:
                dalej
            inaczej:
                jeżeli is_package:
                    spec.submodule_search_locations = []
    inaczej:
        spec.submodule_search_locations = submodule_search_locations
    jeżeli spec.submodule_search_locations == []:
        jeżeli location:
            dirname = _path_split(location)[0]
            spec.submodule_search_locations.append(dirname)

    zwróć spec


# Loaders #####################################################################

klasa WindowsRegistryFinder:

    """Meta path finder dla modules declared w the Windows registry."""

    REGISTRY_KEY = (
        'Software\\Python\\PythonCore\\{sys_version}'
        '\\Modules\\{fullname}')
    REGISTRY_KEY_DEBUG = (
        'Software\\Python\\PythonCore\\{sys_version}'
        '\\Modules\\{fullname}\\Debug')
    DEBUG_BUILD = Nieprawda  # Changed w _setup()

    @classmethod
    def _open_registry(cls, key):
        spróbuj:
            zwróć _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, key)
        wyjąwszy OSError:
            zwróć _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, key)

    @classmethod
    def _search_registry(cls, fullname):
        jeżeli cls.DEBUG_BUILD:
            registry_key = cls.REGISTRY_KEY_DEBUG
        inaczej:
            registry_key = cls.REGISTRY_KEY
        key = registry_key.format(fullname=fullname,
                                  sys_version=sys.version[:3])
        spróbuj:
            przy cls._open_registry(key) jako hkey:
                filepath = _winreg.QueryValue(hkey, '')
        wyjąwszy OSError:
            zwróć Nic
        zwróć filepath

    @classmethod
    def find_spec(cls, fullname, path=Nic, target=Nic):
        filepath = cls._search_registry(fullname)
        jeżeli filepath jest Nic:
            zwróć Nic
        spróbuj:
            _path_stat(filepath)
        wyjąwszy OSError:
            zwróć Nic
        dla loader, suffixes w _get_supported_file_loaders():
            jeżeli filepath.endswith(tuple(suffixes)):
                spec = _bootstrap.spec_from_loader(fullname,
                                                   loader(fullname, filepath),
                                                   origin=filepath)
                zwróć spec

    @classmethod
    def find_module(cls, fullname, path=Nic):
        """Find module named w the registry.

        This method jest deprecated.  Use exec_module() instead.

        """
        spec = cls.find_spec(fullname, path)
        jeżeli spec jest nie Nic:
            zwróć spec.loader
        inaczej:
            zwróć Nic


klasa _LoaderBasics:

    """Base klasa of common code needed by both SourceLoader oraz
    SourcelessFileLoader."""

    def is_package(self, fullname):
        """Concrete implementation of InspectLoader.is_package by checking if
        the path returned by get_filename has a filename of '__init__.py'."""
        filename = _path_split(self.get_filename(fullname))[1]
        filename_base = filename.rsplit('.', 1)[0]
        tail_name = fullname.rpartition('.')[2]
        zwróć filename_base == '__init__' oraz tail_name != '__init__'

    def create_module(self, spec):
        """Use default semantics dla module creation."""

    def exec_module(self, module):
        """Execute the module."""
        code = self.get_code(module.__name__)
        jeżeli code jest Nic:
            podnieś ImportError('cannot load module {!r} when get_code() '
                              'returns Nic'.format(module.__name__))
        _bootstrap._call_with_frames_removed(exec, code, module.__dict__)

    def load_module(self, fullname):
        zwróć _bootstrap._load_module_shim(self, fullname)


klasa SourceLoader(_LoaderBasics):

    def path_mtime(self, path):
        """Optional method that returns the modification time (an int) dla the
        specified path, where path jest a str.

        Raises IOError when the path cannot be handled.
        """
        podnieś IOError

    def path_stats(self, path):
        """Optional method returning a metadata dict dla the specified path
        to by the path (str).
        Possible keys:
        - 'mtime' (mandatory) jest the numeric timestamp of last source
          code modification;
        - 'size' (optional) jest the size w bytes of the source code.

        Implementing this method allows the loader to read bytecode files.
        Raises IOError when the path cannot be handled.
        """
        zwróć {'mtime': self.path_mtime(path)}

    def _cache_bytecode(self, source_path, cache_path, data):
        """Optional method which writes data (bytes) to a file path (a str).

        Implementing this method allows dla the writing of bytecode files.

        The source path jest needed w order to correctly transfer permissions
        """
        # For backwards compatibility, we delegate to set_data()
        zwróć self.set_data(cache_path, data)

    def set_data(self, path, data):
        """Optional method which writes data (bytes) to a file path (a str).

        Implementing this method allows dla the writing of bytecode files.
        """


    def get_source(self, fullname):
        """Concrete implementation of InspectLoader.get_source."""
        path = self.get_filename(fullname)
        spróbuj:
            source_bytes = self.get_data(path)
        wyjąwszy OSError jako exc:
            podnieś ImportError('source nie available through get_data()',
                              name=fullname) z exc
        zwróć decode_source(source_bytes)

    def source_to_code(self, data, path, *, _optimize=-1):
        """Return the code object compiled z source.

        The 'data' argument can be any object type that compile() supports.
        """
        zwróć _bootstrap._call_with_frames_removed(compile, data, path, 'exec',
                                        dont_inherit=Prawda, optimize=_optimize)

    def get_code(self, fullname):
        """Concrete implementation of InspectLoader.get_code.

        Reading of bytecode requires path_stats to be implemented. To write
        bytecode, set_data must also be implemented.

        """
        source_path = self.get_filename(fullname)
        source_mtime = Nic
        spróbuj:
            bytecode_path = cache_from_source(source_path)
        wyjąwszy NotImplementedError:
            bytecode_path = Nic
        inaczej:
            spróbuj:
                st = self.path_stats(source_path)
            wyjąwszy IOError:
                dalej
            inaczej:
                source_mtime = int(st['mtime'])
                spróbuj:
                    data = self.get_data(bytecode_path)
                wyjąwszy OSError:
                    dalej
                inaczej:
                    spróbuj:
                        bytes_data = _validate_bytecode_header(data,
                                source_stats=st, name=fullname,
                                path=bytecode_path)
                    wyjąwszy (ImportError, EOFError):
                        dalej
                    inaczej:
                        _verbose_message('{} matches {}', bytecode_path,
                                        source_path)
                        zwróć _compile_bytecode(bytes_data, name=fullname,
                                                 bytecode_path=bytecode_path,
                                                 source_path=source_path)
        source_bytes = self.get_data(source_path)
        code_object = self.source_to_code(source_bytes, source_path)
        _verbose_message('code object z {}', source_path)
        jeżeli (nie sys.dont_write_bytecode oraz bytecode_path jest nie Nic oraz
                source_mtime jest nie Nic):
            data = _code_to_bytecode(code_object, source_mtime,
                    len(source_bytes))
            spróbuj:
                self._cache_bytecode(source_path, bytecode_path, data)
                _verbose_message('wrote {!r}', bytecode_path)
            wyjąwszy NotImplementedError:
                dalej
        zwróć code_object


klasa FileLoader:

    """Base file loader klasa which implements the loader protocol methods that
    require file system usage."""

    def __init__(self, fullname, path):
        """Cache the module name oraz the path to the file found by the
        finder."""
        self.name = fullname
        self.path = path

    def __eq__(self, other):
        zwróć (self.__class__ == other.__class__ oraz
                self.__dict__ == other.__dict__)

    def __hash__(self):
        zwróć hash(self.name) ^ hash(self.path)

    @_check_name
    def load_module(self, fullname):
        """Load a module z a file.

        This method jest deprecated.  Use exec_module() instead.

        """
        # The only reason dla this method jest dla the name check.
        # Issue #14857: Avoid the zero-argument form of super so the implementation
        # of that form can be updated without przerwijing the frozen module
        zwróć super(FileLoader, self).load_module(fullname)

    @_check_name
    def get_filename(self, fullname):
        """Return the path to the source file jako found by the finder."""
        zwróć self.path

    def get_data(self, path):
        """Return the data z path jako raw bytes."""
        przy _io.FileIO(path, 'r') jako file:
            zwróć file.read()


klasa SourceFileLoader(FileLoader, SourceLoader):

    """Concrete implementation of SourceLoader using the file system."""

    def path_stats(self, path):
        """Return the metadata dla the path."""
        st = _path_stat(path)
        zwróć {'mtime': st.st_mtime, 'size': st.st_size}

    def _cache_bytecode(self, source_path, bytecode_path, data):
        # Adapt between the two APIs
        mode = _calc_mode(source_path)
        zwróć self.set_data(bytecode_path, data, _mode=mode)

    def set_data(self, path, data, *, _mode=0o666):
        """Write bytes data to a file."""
        parent, filename = _path_split(path)
        path_parts = []
        # Figure out what directories are missing.
        dopóki parent oraz nie _path_isdir(parent):
            parent, part = _path_split(parent)
            path_parts.append(part)
        # Create needed directories.
        dla part w reversed(path_parts):
            parent = _path_join(parent, part)
            spróbuj:
                _os.mkdir(parent)
            wyjąwszy FileExistsError:
                # Probably another Python process already created the dir.
                kontynuuj
            wyjąwszy OSError jako exc:
                # Could be a permission error, read-only filesystem: just forget
                # about writing the data.
                _verbose_message('could nie create {!r}: {!r}', parent, exc)
                zwróć
        spróbuj:
            _write_atomic(path, data, _mode)
            _verbose_message('created {!r}', path)
        wyjąwszy OSError jako exc:
            # Same jako above: just don't write the bytecode.
            _verbose_message('could nie create {!r}: {!r}', path, exc)


klasa SourcelessFileLoader(FileLoader, _LoaderBasics):

    """Loader which handles sourceless file imports."""

    def get_code(self, fullname):
        path = self.get_filename(fullname)
        data = self.get_data(path)
        bytes_data = _validate_bytecode_header(data, name=fullname, path=path)
        zwróć _compile_bytecode(bytes_data, name=fullname, bytecode_path=path)

    def get_source(self, fullname):
        """Return Nic jako there jest no source code."""
        zwróć Nic


# Filled w by _setup().
EXTENSION_SUFFIXES = []


klasa ExtensionFileLoader(FileLoader, _LoaderBasics):

    """Loader dla extension modules.

    The constructor jest designed to work przy FileFinder.

    """

    def __init__(self, name, path):
        self.name = name
        self.path = path

    def __eq__(self, other):
        zwróć (self.__class__ == other.__class__ oraz
                self.__dict__ == other.__dict__)

    def __hash__(self):
        zwróć hash(self.name) ^ hash(self.path)

    def create_module(self, spec):
        """Create an unitialized extension module"""
        module = _bootstrap._call_with_frames_removed(
            _imp.create_dynamic, spec)
        _verbose_message('extension module {!r} loaded z {!r}',
                         spec.name, self.path)
        zwróć module

    def exec_module(self, module):
        """Initialize an extension module"""
        _bootstrap._call_with_frames_removed(_imp.exec_dynamic, module)
        _verbose_message('extension module {!r} executed z {!r}',
                         self.name, self.path)

    def is_package(self, fullname):
        """Return Prawda jeżeli the extension module jest a package."""
        file_name = _path_split(self.path)[1]
        zwróć any(file_name == '__init__' + suffix
                   dla suffix w EXTENSION_SUFFIXES)

    def get_code(self, fullname):
        """Return Nic jako an extension module cannot create a code object."""
        zwróć Nic

    def get_source(self, fullname):
        """Return Nic jako extension modules have no source code."""
        zwróć Nic

    @_check_name
    def get_filename(self, fullname):
        """Return the path to the source file jako found by the finder."""
        zwróć self.path


klasa _NamespacePath:
    """Represents a namespace package's path.  It uses the module name
    to find its parent module, oraz z there it looks up the parent's
    __path__.  When this changes, the module's own path jest recomputed,
    using path_finder.  For top-level modules, the parent module's path
    jest sys.path."""

    def __init__(self, name, path, path_finder):
        self._name = name
        self._path = path
        self._last_parent_path = tuple(self._get_parent_path())
        self._path_finder = path_finder

    def _find_parent_path_names(self):
        """Returns a tuple of (parent-module-name, parent-path-attr-name)"""
        parent, dot, me = self._name.rpartition('.')
        jeżeli dot == '':
            # This jest a top-level module. sys.path contains the parent path.
            zwróć 'sys', 'path'
        # Not a top-level module. parent-module.__path__ contains the
        #  parent path.
        zwróć parent, '__path__'

    def _get_parent_path(self):
        parent_module_name, path_attr_name = self._find_parent_path_names()
        zwróć getattr(sys.modules[parent_module_name], path_attr_name)

    def _recalculate(self):
        # If the parent's path has changed, recalculate _path
        parent_path = tuple(self._get_parent_path()) # Make a copy
        jeżeli parent_path != self._last_parent_path:
            spec = self._path_finder(self._name, parent_path)
            # Note that no changes are made jeżeli a loader jest returned, but we
            #  do remember the new parent path
            jeżeli spec jest nie Nic oraz spec.loader jest Nic:
                jeżeli spec.submodule_search_locations:
                    self._path = spec.submodule_search_locations
            self._last_parent_path = parent_path     # Save the copy
        zwróć self._path

    def __iter__(self):
        zwróć iter(self._recalculate())

    def __len__(self):
        zwróć len(self._recalculate())

    def __repr__(self):
        zwróć '_NamespacePath({!r})'.format(self._path)

    def __contains__(self, item):
        zwróć item w self._recalculate()

    def append(self, item):
        self._path.append(item)


# We use this exclusively w module_from_spec() dla backward-compatibility.
klasa _NamespaceLoader:
    def __init__(self, name, path, path_finder):
        self._path = _NamespacePath(name, path, path_finder)

    @classmethod
    def module_repr(cls, module):
        """Return repr dla the module.

        The method jest deprecated.  The zaimportuj machinery does the job itself.

        """
        zwróć '<module {!r} (namespace)>'.format(module.__name__)

    def is_package(self, fullname):
        zwróć Prawda

    def get_source(self, fullname):
        zwróć ''

    def get_code(self, fullname):
        zwróć compile('', '<string>', 'exec', dont_inherit=Prawda)

    def create_module(self, spec):
        """Use default semantics dla module creation."""

    def exec_module(self, module):
        dalej

    def load_module(self, fullname):
        """Load a namespace module.

        This method jest deprecated.  Use exec_module() instead.

        """
        # The zaimportuj system never calls this method.
        _verbose_message('namespace module loaded przy path {!r}', self._path)
        zwróć _bootstrap._load_module_shim(self, fullname)


# Finders #####################################################################

klasa PathFinder:

    """Meta path finder dla sys.path oraz package __path__ attributes."""

    @classmethod
    def invalidate_caches(cls):
        """Call the invalidate_caches() method on all path entry finders
        stored w sys.path_importer_caches (where implemented)."""
        dla finder w sys.path_importer_cache.values():
            jeżeli hasattr(finder, 'invalidate_caches'):
                finder.invalidate_caches()

    @classmethod
    def _path_hooks(cls, path):
        """Search sequence of hooks dla a finder dla 'path'.

        If 'hooks' jest false then use sys.path_hooks.

        """
        jeżeli sys.path_hooks jest nie Nic oraz nie sys.path_hooks:
            _warnings.warn('sys.path_hooks jest empty', ImportWarning)
        dla hook w sys.path_hooks:
            spróbuj:
                zwróć hook(path)
            wyjąwszy ImportError:
                kontynuuj
        inaczej:
            zwróć Nic

    @classmethod
    def _path_importer_cache(cls, path):
        """Get the finder dla the path entry z sys.path_importer_cache.

        If the path entry jest nie w the cache, find the appropriate finder
        oraz cache it. If no finder jest available, store Nic.

        """
        jeżeli path == '':
            spróbuj:
                path = _os.getcwd()
            wyjąwszy FileNotFoundError:
                # Don't cache the failure jako the cwd can easily change to
                # a valid directory later on.
                zwróć Nic
        spróbuj:
            finder = sys.path_importer_cache[path]
        wyjąwszy KeyError:
            finder = cls._path_hooks(path)
            sys.path_importer_cache[path] = finder
        zwróć finder

    @classmethod
    def _legacy_get_spec(cls, fullname, finder):
        # This would be a good place dla a DeprecationWarning if
        # we ended up going that route.
        jeżeli hasattr(finder, 'find_loader'):
            loader, portions = finder.find_loader(fullname)
        inaczej:
            loader = finder.find_module(fullname)
            portions = []
        jeżeli loader jest nie Nic:
            zwróć _bootstrap.spec_from_loader(fullname, loader)
        spec = _bootstrap.ModuleSpec(fullname, Nic)
        spec.submodule_search_locations = portions
        zwróć spec

    @classmethod
    def _get_spec(cls, fullname, path, target=Nic):
        """Find the loader albo namespace_path dla this module/package name."""
        # If this ends up being a namespace package, namespace_path jest
        #  the list of paths that will become its __path__
        namespace_path = []
        dla entry w path:
            jeżeli nie isinstance(entry, (str, bytes)):
                kontynuuj
            finder = cls._path_importer_cache(entry)
            jeżeli finder jest nie Nic:
                jeżeli hasattr(finder, 'find_spec'):
                    spec = finder.find_spec(fullname, target)
                inaczej:
                    spec = cls._legacy_get_spec(fullname, finder)
                jeżeli spec jest Nic:
                    kontynuuj
                jeżeli spec.loader jest nie Nic:
                    zwróć spec
                portions = spec.submodule_search_locations
                jeżeli portions jest Nic:
                    podnieś ImportError('spec missing loader')
                # This jest possibly part of a namespace package.
                #  Remember these path entries (jeżeli any) dla when we
                #  create a namespace package, oraz continue iterating
                #  on path.
                namespace_path.extend(portions)
        inaczej:
            spec = _bootstrap.ModuleSpec(fullname, Nic)
            spec.submodule_search_locations = namespace_path
            zwróć spec

    @classmethod
    def find_spec(cls, fullname, path=Nic, target=Nic):
        """find the module on sys.path albo 'path' based on sys.path_hooks oraz
        sys.path_importer_cache."""
        jeżeli path jest Nic:
            path = sys.path
        spec = cls._get_spec(fullname, path, target)
        jeżeli spec jest Nic:
            zwróć Nic
        albo_inaczej spec.loader jest Nic:
            namespace_path = spec.submodule_search_locations
            jeżeli namespace_path:
                # We found at least one namespace path.  Return a
                #  spec which can create the namespace package.
                spec.origin = 'namespace'
                spec.submodule_search_locations = _NamespacePath(fullname, namespace_path, cls._get_spec)
                zwróć spec
            inaczej:
                zwróć Nic
        inaczej:
            zwróć spec

    @classmethod
    def find_module(cls, fullname, path=Nic):
        """find the module on sys.path albo 'path' based on sys.path_hooks oraz
        sys.path_importer_cache.

        This method jest deprecated.  Use find_spec() instead.

        """
        spec = cls.find_spec(fullname, path)
        jeżeli spec jest Nic:
            zwróć Nic
        zwróć spec.loader


klasa FileFinder:

    """File-based finder.

    Interactions przy the file system are cached dla performance, being
    refreshed when the directory the finder jest handling has been modified.

    """

    def __init__(self, path, *loader_details):
        """Initialize przy the path to search on oraz a variable number of
        2-tuples containing the loader oraz the file suffixes the loader
        recognizes."""
        loaders = []
        dla loader, suffixes w loader_details:
            loaders.extend((suffix, loader) dla suffix w suffixes)
        self._loaders = loaders
        # Base (directory) path
        self.path = path albo '.'
        self._path_mtime = -1
        self._path_cache = set()
        self._relaxed_path_cache = set()

    def invalidate_caches(self):
        """Invalidate the directory mtime."""
        self._path_mtime = -1

    find_module = _find_module_shim

    def find_loader(self, fullname):
        """Try to find a loader dla the specified module, albo the namespace
        package portions. Returns (loader, list-of-portions).

        This method jest deprecated.  Use find_spec() instead.

        """
        spec = self.find_spec(fullname)
        jeżeli spec jest Nic:
            zwróć Nic, []
        zwróć spec.loader, spec.submodule_search_locations albo []

    def _get_spec(self, loader_class, fullname, path, smsl, target):
        loader = loader_class(fullname, path)
        zwróć spec_from_file_location(fullname, path, loader=loader,
                                       submodule_search_locations=smsl)

    def find_spec(self, fullname, target=Nic):
        """Try to find a loader dla the specified module, albo the namespace
        package portions. Returns (loader, list-of-portions)."""
        is_namespace = Nieprawda
        tail_module = fullname.rpartition('.')[2]
        spróbuj:
            mtime = _path_stat(self.path albo _os.getcwd()).st_mtime
        wyjąwszy OSError:
            mtime = -1
        jeżeli mtime != self._path_mtime:
            self._fill_cache()
            self._path_mtime = mtime
        # tail_module keeps the original casing, dla __file__ oraz friends
        jeżeli _relax_case():
            cache = self._relaxed_path_cache
            cache_module = tail_module.lower()
        inaczej:
            cache = self._path_cache
            cache_module = tail_module
        # Check jeżeli the module jest the name of a directory (and thus a package).
        jeżeli cache_module w cache:
            base_path = _path_join(self.path, tail_module)
            dla suffix, loader_class w self._loaders:
                init_filename = '__init__' + suffix
                full_path = _path_join(base_path, init_filename)
                jeżeli _path_isfile(full_path):
                    zwróć self._get_spec(loader_class, fullname, full_path, [base_path], target)
            inaczej:
                # If a namespace package, zwróć the path jeżeli we don't
                #  find a module w the next section.
                is_namespace = _path_isdir(base_path)
        # Check dla a file w/ a proper suffix exists.
        dla suffix, loader_class w self._loaders:
            full_path = _path_join(self.path, tail_module + suffix)
            _verbose_message('trying {}'.format(full_path), verbosity=2)
            jeżeli cache_module + suffix w cache:
                jeżeli _path_isfile(full_path):
                    zwróć self._get_spec(loader_class, fullname, full_path, Nic, target)
        jeżeli is_namespace:
            _verbose_message('possible namespace dla {}'.format(base_path))
            spec = _bootstrap.ModuleSpec(fullname, Nic)
            spec.submodule_search_locations = [base_path]
            zwróć spec
        zwróć Nic

    def _fill_cache(self):
        """Fill the cache of potential modules oraz packages dla this directory."""
        path = self.path
        spróbuj:
            contents = _os.listdir(path albo _os.getcwd())
        wyjąwszy (FileNotFoundError, PermissionError, NotADirectoryError):
            # Directory has either been removed, turned into a file, albo made
            # unreadable.
            contents = []
        # We store two cached versions, to handle runtime changes of the
        # PYTHONCASEOK environment variable.
        jeżeli nie sys.platform.startswith('win'):
            self._path_cache = set(contents)
        inaczej:
            # Windows users can zaimportuj modules przy case-insensitive file
            # suffixes (dla legacy reasons). Make the suffix lowercase here
            # so it's done once instead of dla every import. This jest safe as
            # the specified suffixes to check against are always specified w a
            # case-sensitive manner.
            lower_suffix_contents = set()
            dla item w contents:
                name, dot, suffix = item.partition('.')
                jeżeli dot:
                    new_name = '{}.{}'.format(name, suffix.lower())
                inaczej:
                    new_name = name
                lower_suffix_contents.add(new_name)
            self._path_cache = lower_suffix_contents
        jeżeli sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):
            self._relaxed_path_cache = {fn.lower() dla fn w contents}

    @classmethod
    def path_hook(cls, *loader_details):
        """A klasa method which returns a closure to use on sys.path_hook
        which will zwróć an instance using the specified loaders oraz the path
        called on the closure.

        If the path called on the closure jest nie a directory, ImportError jest
        podnieśd.

        """
        def path_hook_for_FileFinder(path):
            """Path hook dla importlib.machinery.FileFinder."""
            jeżeli nie _path_isdir(path):
                podnieś ImportError('only directories are supported', path=path)
            zwróć cls(path, *loader_details)

        zwróć path_hook_for_FileFinder

    def __repr__(self):
        zwróć 'FileFinder({!r})'.format(self.path)


# Import setup ###############################################################

def _fix_up_module(ns, name, pathname, cpathname=Nic):
    # This function jest used by PyImport_ExecCodeModuleObject().
    loader = ns.get('__loader__')
    spec = ns.get('__spec__')
    jeżeli nie loader:
        jeżeli spec:
            loader = spec.loader
        albo_inaczej pathname == cpathname:
            loader = SourcelessFileLoader(name, pathname)
        inaczej:
            loader = SourceFileLoader(name, pathname)
    jeżeli nie spec:
        spec = spec_from_file_location(name, pathname, loader=loader)
    spróbuj:
        ns['__spec__'] = spec
        ns['__loader__'] = loader
        ns['__file__'] = pathname
        ns['__cached__'] = cpathname
    wyjąwszy Exception:
        # Not important enough to report.
        dalej


def _get_supported_file_loaders():
    """Returns a list of file-based module loaders.

    Each item jest a tuple (loader, suffixes).
    """
    extensions = ExtensionFileLoader, _imp.extension_suffixes()
    source = SourceFileLoader, SOURCE_SUFFIXES
    bytecode = SourcelessFileLoader, BYTECODE_SUFFIXES
    zwróć [extensions, source, bytecode]


def _setup(_bootstrap_module):
    """Setup the path-based importers dla importlib by importing needed
    built-in modules oraz injecting them into the global namespace.

    Other components are extracted z the core bootstrap module.

    """
    global sys, _imp, _bootstrap
    _bootstrap = _bootstrap_module
    sys = _bootstrap.sys
    _imp = _bootstrap._imp

    # Directly load built-in modules needed during bootstrap.
    self_module = sys.modules[__name__]
    dla builtin_name w ('_io', '_warnings', 'builtins', 'marshal'):
        jeżeli builtin_name nie w sys.modules:
            builtin_module = _bootstrap._builtin_from_name(builtin_name)
        inaczej:
            builtin_module = sys.modules[builtin_name]
        setattr(self_module, builtin_name, builtin_module)

    # Directly load the os module (needed during bootstrap).
    os_details = ('posix', ['/']), ('nt', ['\\', '/'])
    dla builtin_os, path_separators w os_details:
        # Assumption made w _path_join()
        assert all(len(sep) == 1 dla sep w path_separators)
        path_sep = path_separators[0]
        jeżeli builtin_os w sys.modules:
            os_module = sys.modules[builtin_os]
            przerwij
        inaczej:
            spróbuj:
                os_module = _bootstrap._builtin_from_name(builtin_os)
                przerwij
            wyjąwszy ImportError:
                kontynuuj
    inaczej:
        podnieś ImportError('importlib requires posix albo nt')
    setattr(self_module, '_os', os_module)
    setattr(self_module, 'path_sep', path_sep)
    setattr(self_module, 'path_separators', ''.join(path_separators))

    # Directly load the _thread module (needed during bootstrap).
    spróbuj:
        thread_module = _bootstrap._builtin_from_name('_thread')
    wyjąwszy ImportError:
        # Python was built without threads
        thread_module = Nic
    setattr(self_module, '_thread', thread_module)

    # Directly load the _weakref module (needed during bootstrap).
    weakref_module = _bootstrap._builtin_from_name('_weakref')
    setattr(self_module, '_weakref', weakref_module)

    # Directly load the winreg module (needed during bootstrap).
    jeżeli builtin_os == 'nt':
        winreg_module = _bootstrap._builtin_from_name('winreg')
        setattr(self_module, '_winreg', winreg_module)

    # Constants
    setattr(self_module, '_relax_case', _make_relax_case())
    EXTENSION_SUFFIXES.extend(_imp.extension_suffixes())
    jeżeli builtin_os == 'nt':
        SOURCE_SUFFIXES.append('.pyw')
        jeżeli '_d.pyd' w EXTENSION_SUFFIXES:
            WindowsRegistryFinder.DEBUG_BUILD = Prawda


def _install(_bootstrap_module):
    """Install the path-based zaimportuj components."""
    _setup(_bootstrap_module)
    supported_loaders = _get_supported_file_loaders()
    sys.path_hooks.extend([FileFinder.path_hook(*supported_loaders)])
    jeżeli _os.__name__ == 'nt':
        sys.meta_path.append(WindowsRegistryFinder)
    sys.meta_path.append(PathFinder)

    # XXX We expose a couple of classes w _bootstrap dla the sake of
    # a setuptools bug (https://bitbucket.org/pypa/setuptools/issue/378).
    _bootstrap_module.FileFinder = FileFinder
    _bootstrap_module.SourceFileLoader = SourceFileLoader
