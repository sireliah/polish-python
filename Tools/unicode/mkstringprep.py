zaimportuj re, sys
z unicodedata zaimportuj ucd_3_2_0 jako unicodedata

jeżeli sys.maxunicode == 65535:
    podnieś RuntimeError("need UCS-4 Python")

def gen_category(cats):
    dla i w range(0, 0x110000):
        jeżeli unicodedata.category(chr(i)) w cats:
            uzyskaj(i)

def gen_bidirectional(cats):
    dla i w range(0, 0x110000):
        jeżeli unicodedata.bidirectional(chr(i)) w cats:
            uzyskaj(i)

def compact_set(l):
    single = []
    tuple = []
    prev = Nic
    span = 0
    dla e w l:
        jeżeli prev jest Nic:
            prev = e
            span = 0
            kontynuuj
        jeżeli prev+span+1 != e:
            jeżeli span > 2:
                tuple.append((prev,prev+span+1))
            inaczej:
                dla i w range(prev, prev+span+1):
                    single.append(i)
            prev = e
            span = 0
        inaczej:
            span += 1
    jeżeli span:
        tuple.append((prev,prev+span+1))
    inaczej:
        single.append(prev)
    jeżeli nie single oraz len(tuple) == 1:
        tuple = "range(%d,%d)" % tuple[0]
    inaczej:
        tuple = " + ".join("list(range(%d,%d))" % t dla t w tuple)
    jeżeli nie single:
        zwróć "set(%s)" % tuple
    jeżeli nie tuple:
        zwróć "set(%r)" % (single,)
    zwróć "set(%r + %s)" % (single, tuple)

############## Read the tables w the RFC #######################

przy open("rfc3454.txt") jako f:
    data = f.readlines()

tables = []
curname = Nic
dla l w data:
    l = l.strip()
    jeżeli nie l:
        kontynuuj
    # Skip RFC page przerwijs
    jeżeli l.startswith(("Hoffman & Blanchet", "RFC 3454")):
        kontynuuj
    # Find start/end lines
    m = re.match("----- (Start|End) Table ([A-Z](.[0-9])+) -----", l)
    jeżeli m:
        jeżeli m.group(1) == "Start":
            jeżeli curname:
                podnieś RuntimeError("Double Start", (curname, l))
            curname = m.group(2)
            table = {}
            tables.append((curname, table))
            kontynuuj
        inaczej:
            jeżeli nie curname:
                podnieś RuntimeError("End without start", l)
            jeżeli curname != m.group(2):
                podnieś RuntimeError("Unexpected end", l)
            curname = Nic
            kontynuuj
    jeżeli nie curname:
        kontynuuj
    # Now we are w a table
    fields = l.split(";")
    jeżeli len(fields) > 1:
        # Drop comment field
        fields = fields[:-1]
    jeżeli len(fields) == 1:
        fields = fields[0].split("-")
        jeżeli len(fields) > 1:
            # range
            spróbuj:
                start, end = fields
            wyjąwszy ValueError:
                podnieś RuntimeError("Unpacking problem", l)
        inaczej:
            start = end = fields[0]
        start = int(start, 16)
        end = int(end, 16)
        dla i w range(start, end+1):
            table[i] = i
    inaczej:
        code, value = fields
        value = value.strip()
        jeżeli value:
            value = [int(v, 16) dla v w value.split(" ")]
        inaczej:
            # table B.1
            value = Nic
        table[int(code, 16)] = value

########### Generate compact Python versions of the tables #############

print("""# This file jest generated by mkstringprep.py. DO NOT EDIT.
\"\"\"Library that exposes various tables found w the StringPrep RFC 3454.

There are two kinds of tables: sets, dla which a member test jest provided,
and mappings, dla which a mapping function jest provided.
\"\"\"

z unicodedata zaimportuj ucd_3_2_0 jako unicodedata
""")

print("assert unicodedata.unidata_version == %r" % (unicodedata.unidata_version,))

# A.1 jest the table of unassigned characters
# XXX Plane 15 PUA jest listed jako unassigned w Python.
name, table = tables[0]
usuń tables[0]
assert name == "A.1"
table = set(table.keys())
Cn = set(gen_category(["Cn"]))

# FDD0..FDEF are process internal codes
Cn -= set(range(0xFDD0, 0xFDF0))
# nie a character
Cn -= set(range(0xFFFE, 0x110000, 0x10000))
Cn -= set(range(0xFFFF, 0x110000, 0x10000))

# assert table == Cn

print("""
def in_table_a1(code):
    jeżeli unicodedata.category(code) != 'Cn': zwróć Nieprawda
    c = ord(code)
    jeżeli 0xFDD0 <= c < 0xFDF0: zwróć Nieprawda
    zwróć (c & 0xFFFF) nie w (0xFFFE, 0xFFFF)
""")

# B.1 cannot easily be derived
name, table = tables[0]
usuń tables[0]
assert name == "B.1"
table = sorted(table.keys())
print("""
b1_set = """ + compact_set(table) + """
def in_table_b1(code):
    zwróć ord(code) w b1_set
""")

# B.2 oraz B.3 jest case folding.
# It takes CaseFolding.txt into account, which jest
# nie available w the Python database. Since
# B.2 jest derived z B.3, we process B.3 first.
# B.3 supposedly *is* CaseFolding-3.2.0.txt.

name, table_b2 = tables[0]
usuń tables[0]
assert name == "B.2"

name, table_b3 = tables[0]
usuń tables[0]
assert name == "B.3"

# B.3 jest mostly Python's .lower, wyjąwszy dla a number
# of special cases, e.g. considering canonical forms.

b3_exceptions = {}

dla k,v w table_b2.items():
    jeżeli list(map(ord, chr(k).lower())) != v:
        b3_exceptions[k] = "".join(map(chr,v))

b3 = sorted(b3_exceptions.items())

print("""
b3_exceptions = {""")
dla i, kv w enumerate(b3):
    print("0x%x:%a," % kv, end=' ')
    jeżeli i % 4 == 3:
        print()
print("}")

print("""
def map_table_b3(code):
    r = b3_exceptions.get(ord(code))
    jeżeli r jest nie Nic: zwróć r
    zwróć code.lower()
""")

def map_table_b3(code):
    r = b3_exceptions.get(ord(code))
    jeżeli r jest nie Nic: zwróć r
    zwróć code.lower()

# B.2 jest case folding dla NFKC. This jest the same jako B.3,
# wyjąwszy where NormalizeWithKC(Fold(a)) !=
# NormalizeWithKC(Fold(NormalizeWithKC(Fold(a))))

def map_table_b2(a):
    al = map_table_b3(a)
    b = unicodedata.normalize("NFKC", al)
    bl = "".join([map_table_b3(ch) dla ch w b])
    c = unicodedata.normalize("NFKC", bl)
    jeżeli b != c:
        zwróć c
    inaczej:
        zwróć al

specials = {}
dla k,v w table_b2.items():
    jeżeli list(map(ord, map_table_b2(chr(k)))) != v:
        specials[k] = v

# B.3 should nie add any additional special cases
assert specials == {}

print("""
def map_table_b2(a):
    al = map_table_b3(a)
    b = unicodedata.normalize("NFKC", al)
    bl = "".join([map_table_b3(ch) dla ch w b])
    c = unicodedata.normalize("NFKC", bl)
    jeżeli b != c:
        zwróć c
    inaczej:
        zwróć al
""")

# C.1.1 jest a table przy a single character
name, table = tables[0]
usuń tables[0]
assert name == "C.1.1"
assert table == {0x20:0x20}

print("""
def in_table_c11(code):
    zwróć code == " "
""")

# C.1.2 jest the rest of all space characters
name, table = tables[0]
usuń tables[0]
assert name == "C.1.2"

# table = set(table.keys())
# Zs = set(gen_category(["Zs"])) - {0x20}
# assert Zs == table

print("""
def in_table_c12(code):
    zwróć unicodedata.category(code) == "Zs" oraz code != " "

def in_table_c11_c12(code):
    zwróć unicodedata.category(code) == "Zs"
""")

# C.2.1 ASCII control characters
name, table_c21 = tables[0]
usuń tables[0]
assert name == "C.2.1"

Cc = set(gen_category(["Cc"]))
Cc_ascii = Cc & set(range(128))
table_c21 = set(table_c21.keys())
assert Cc_ascii == table_c21

print("""
def in_table_c21(code):
    zwróć ord(code) < 128 oraz unicodedata.category(code) == "Cc"
""")

# C.2.2 Non-ASCII control characters. It also includes
# a number of characters w category Cf.
name, table_c22 = tables[0]
usuń tables[0]
assert name == "C.2.2"

Cc_nonascii = Cc - Cc_ascii
table_c22 = set(table_c22.keys())
assert len(Cc_nonascii - table_c22) == 0

specials = list(table_c22 - Cc_nonascii)
specials.sort()

print("""c22_specials = """ + compact_set(specials) + """
def in_table_c22(code):
    c = ord(code)
    jeżeli c < 128: zwróć Nieprawda
    jeżeli unicodedata.category(code) == "Cc": zwróć Prawda
    zwróć c w c22_specials

def in_table_c21_c22(code):
    zwróć unicodedata.category(code) == "Cc" albo \\
           ord(code) w c22_specials
""")

# C.3 Private use
name, table = tables[0]
usuń tables[0]
assert name == "C.3"

Co = set(gen_category(["Co"]))
assert set(table.keys()) == Co

print("""
def in_table_c3(code):
    zwróć unicodedata.category(code) == "Co"
""")

# C.4 Non-character code points, xFFFE, xFFFF
# plus process internal codes
name, table = tables[0]
usuń tables[0]
assert name == "C.4"

nonchar = set(range(0xFDD0,0xFDF0))
nonchar.update(range(0xFFFE,0x110000,0x10000))
nonchar.update(range(0xFFFF,0x110000,0x10000))
table = set(table.keys())
assert table == nonchar

print("""
def in_table_c4(code):
    c = ord(code)
    jeżeli c < 0xFDD0: zwróć Nieprawda
    jeżeli c < 0xFDF0: zwróć Prawda
    zwróć (ord(code) & 0xFFFF) w (0xFFFE, 0xFFFF)
""")

# C.5 Surrogate codes
name, table = tables[0]
usuń tables[0]
assert name == "C.5"

Cs = set(gen_category(["Cs"]))
assert set(table.keys()) == Cs

print("""
def in_table_c5(code):
    zwróć unicodedata.category(code) == "Cs"
""")

# C.6 Inappropriate dla plain text
name, table = tables[0]
usuń tables[0]
assert name == "C.6"

table = sorted(table.keys())

print("""
c6_set = """ + compact_set(table) + """
def in_table_c6(code):
    zwróć ord(code) w c6_set
""")

# C.7 Inappropriate dla canonical representation
name, table = tables[0]
usuń tables[0]
assert name == "C.7"

table = sorted(table.keys())

print("""
c7_set = """ + compact_set(table) + """
def in_table_c7(code):
    zwróć ord(code) w c7_set
""")

# C.8 Change display properties albo are deprecated
name, table = tables[0]
usuń tables[0]
assert name == "C.8"

table = sorted(table.keys())

print("""
c8_set = """ + compact_set(table) + """
def in_table_c8(code):
    zwróć ord(code) w c8_set
""")

# C.9 Tagging characters
name, table = tables[0]
usuń tables[0]
assert name == "C.9"

table = sorted(table.keys())

print("""
c9_set = """ + compact_set(table) + """
def in_table_c9(code):
    zwróć ord(code) w c9_set
""")

# D.1 Characters przy bidirectional property "R" albo "AL"
name, table = tables[0]
usuń tables[0]
assert name == "D.1"

RandAL = set(gen_bidirectional(["R","AL"]))
assert set(table.keys()) == RandAL

print("""
def in_table_d1(code):
    zwróć unicodedata.bidirectional(code) w ("R","AL")
""")

# D.2 Characters przy bidirectional property "L"
name, table = tables[0]
usuń tables[0]
assert name == "D.2"

L = set(gen_bidirectional(["L"]))
assert set(table.keys()) == L

print("""
def in_table_d2(code):
    zwróć unicodedata.bidirectional(code) == "L"
""")
